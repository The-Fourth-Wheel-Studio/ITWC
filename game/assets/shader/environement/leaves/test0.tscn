[gd_scene load_steps=31 format=3 uid="uid://d1mm0df2qipss"]

[ext_resource type="Texture2D" uid="uid://do186lwo5knfi" path="res://game/assets/texture/environement/leave/maskBebou.png" id="2_n7c4t"]
[ext_resource type="Script" path="res://game/assets/shader/environement/leaves/getVertexPos.gd" id="3_ed2c0"]

[sub_resource type="Shader" id="Shader_garm8"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_3eyts"]
render_priority = 0
shader = SubResource("Shader_garm8")
shader_parameter/Albedo = Color(2.27117e-06, 0.268987, 0.00333835, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-0.590415, -0.203768, -0.143798)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_8lmk2"]
material = SubResource("ShaderMaterial_3eyts")
orientation = 2

[sub_resource type="Shader" id="Shader_n3ctp"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_mx75e"]
render_priority = 0
shader = SubResource("Shader_n3ctp")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(0.47365, -0.44287, -0.694955)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_7dwcj"]
material = SubResource("ShaderMaterial_mx75e")
orientation = 2

[sub_resource type="Shader" id="Shader_fmeuv"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_audnc"]
render_priority = 0
shader = SubResource("Shader_fmeuv")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-0.0839944, 0.24612, -0.459154)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_hqrbb"]
material = SubResource("ShaderMaterial_audnc")
orientation = 2

[sub_resource type="Shader" id="Shader_kn5nr"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_a3t4i"]
render_priority = 0
shader = SubResource("Shader_kn5nr")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-0.646141, 0.320493, -0.0512024)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_y8ayx"]
material = SubResource("ShaderMaterial_a3t4i")
orientation = 2

[sub_resource type="Shader" id="Shader_wcp65"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_dooff"]
render_priority = 0
shader = SubResource("Shader_wcp65")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(0.323407, -0.0555513, -0.216544)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_4wtva"]
material = SubResource("ShaderMaterial_dooff")
orientation = 2

[sub_resource type="Shader" id="Shader_aj063"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_fgfgl"]
render_priority = 0
shader = SubResource("Shader_aj063")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-0.389843, -0.0348954, -0.0304891)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_e3mei"]
material = SubResource("ShaderMaterial_fgfgl")
orientation = 2

[sub_resource type="Shader" id="Shader_j5eaw"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_h5fkk"]
render_priority = 0
shader = SubResource("Shader_j5eaw")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(0.496506, -0.126582, -0.31954)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_d75g4"]
material = SubResource("ShaderMaterial_h5fkk")
orientation = 2

[sub_resource type="Shader" id="Shader_xvh3s"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_buhq8"]
render_priority = 0
shader = SubResource("Shader_xvh3s")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-1.00978, -0.113927, -0.269931)
shader_parameter/leaveTexture = ExtResource("2_n7c4t")

[sub_resource type="PlaneMesh" id="PlaneMesh_tkxfc"]
material = SubResource("ShaderMaterial_buhq8")
orientation = 2

[sub_resource type="Shader" id="Shader_ci31p"]
code = "shader_type spatial;

uniform vec3 Albedo : source_color = vec3(1, 1, 1);
uniform float Roughness : hint_range(0.0, 1.0) = 1.0;
uniform float Metallicness : hint_range(0.0, 1.0) = 0.0;
uniform sampler2D leaveTexture;
uniform vec3 pos;

varying vec4 vertex_world;
varying vec3 Vertex;

// Fonctions utilitaires
float DistributionGGX(float cos_theta_m, float alpha) {
    float alpha2 = alpha * alpha;
    float d = 1.0 + (alpha2 - 1.0) * cos_theta_m * cos_theta_m;
    return alpha2 / (PI * d * d);
}

float GeometryGGX(float NdotL, float NdotV, float alpha) {
    return 0.5 / mix(2.0 * NdotL * NdotV, NdotL + NdotV, alpha);
}

vec3 SchlickBaseReflectivity(float metallics, float speculars, vec3 albedos) {
    float dielectric = 0.04 * speculars * speculars;
    return mix(vec3(dielectric), albedos, vec3(metallics));
}

float SchlickFresnel(float u) {
    float m = 1.0 - u;
    float m2 = m * m;
    return m2 * m2 * m;
}

// Shader principal
void vertex() {
    // Calculer VERTEX_WORLD dans le vertex shader pour passer au fragment shader
    mat4 modified_model_view = VIEW_MATRIX * mat4(
        INV_VIEW_MATRIX[0],
        INV_VIEW_MATRIX[1],
        INV_VIEW_MATRIX[2],
        MODEL_MATRIX[3]
    );
    MODELVIEW_MATRIX = modified_model_view;
    
    // Calcule la position du vertex dans l'espace monde
    vertex_world = INV_VIEW_MATRIX * vec4(VERTEX, 1.0);
	Vertex = VERTEX;
}

void fragment() {
    // Utiliser l'albédo de base pour la couleur
	vec4 tex = texture(leaveTexture,UV);
    ALBEDO = tex.xyz * Albedo;
	ALPHA = tex.a;
	METALLIC = 0.0;
	ROUGHNESS = 1.0;
	
}

void light() {
    // Calculer une \"normale sphérique\" en utilisant la position locale
    vec3 spherical_normal = normalize(pos);

    // Utiliser la normale sphérique pour les calculs d'éclairage
    vec3 lightColor = LIGHT_COLOR / PI;
    vec3 half = normalize(VIEW + LIGHT);
    
    float NdotL = max(dot(spherical_normal, LIGHT), 0.0);
    float NdotV = max(dot(spherical_normal, VIEW), 0.0);
    float NdotH = max(dot(spherical_normal, half), 0.0);
    float LdotH = max(dot(LIGHT, half), 0.0);

    // Diffuse light (Lambert)
    DIFFUSE_LIGHT += NdotL * ATTENUATION * lightColor;

    // Specular light (Schlick-GGX)
    float ggxAlpha = Roughness * Roughness;
    float D = DistributionGGX(NdotH, ggxAlpha);
    float G = GeometryGGX(NdotL, NdotV, ggxAlpha);

    vec3 f0 = SchlickBaseReflectivity(Metallicness, 0.5, Albedo); // SPECULAR_AMOUNT par défaut à 0.5
    float LdotH5 = SchlickFresnel(LdotH);
    float f90 = clamp(50.0 * f0.g, 0.0, 1.0);
    vec3 F = f0 + (f90 - f0) * LdotH5;
    
    vec3 specularBRDF = max(NdotL * D * G * F, 0.0);
    SPECULAR_LIGHT += specularBRDF * LIGHT_COLOR * ATTENUATION;
}
"

[sub_resource type="CompressedTexture2D" id="CompressedTexture2D_ypoo3"]
load_path = "res://.godot/imported/maskBebou.png-4ff2c7ba34cd1d2588dde8c622ed0075.s3tc.ctex"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_50dk4"]
render_priority = 0
shader = SubResource("Shader_ci31p")
shader_parameter/Albedo = Color(0, 0.270588, 0.00392157, 1)
shader_parameter/Roughness = 1.0
shader_parameter/Metallicness = 0.0
shader_parameter/pos = Vector3(-0.226848, 0.456031, -0.0190149)
shader_parameter/leaveTexture = SubResource("CompressedTexture2D_ypoo3")

[sub_resource type="PlaneMesh" id="PlaneMesh_ed4ov"]
material = SubResource("ShaderMaterial_50dk4")
orientation = 2

[node name="leave" type="Node3D"]

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(-0.866023, -0.433016, 0.250001, 0.104315, 0.332524, 0.937308, -0.489001, 0.83781, -0.242803, 0, 0, 0)
shadow_enabled = true

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.590415, -0.203768, -0.143798)
mesh = SubResource("PlaneMesh_8lmk2")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D3" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.47365, -0.44287, -0.694955)
mesh = SubResource("PlaneMesh_7dwcj")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D4" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.0839944, 0.24612, -0.459154)
mesh = SubResource("PlaneMesh_hqrbb")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D5" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.646141, 0.320493, -0.0512024)
mesh = SubResource("PlaneMesh_y8ayx")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D6" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.323407, -0.0555513, -0.216544)
mesh = SubResource("PlaneMesh_4wtva")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D7" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.389843, -0.0348954, -0.0304891)
mesh = SubResource("PlaneMesh_e3mei")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D8" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.496506, -0.126582, -0.31954)
mesh = SubResource("PlaneMesh_d75g4")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D9" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.00978, -0.113927, -0.269931)
mesh = SubResource("PlaneMesh_tkxfc")
script = ExtResource("3_ed2c0")

[node name="MeshInstance3D10" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.226848, 0.456031, -0.0190149)
mesh = SubResource("PlaneMesh_ed4ov")
script = ExtResource("3_ed2c0")
